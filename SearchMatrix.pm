#!/usr/bin/perl -w
package SearchMatrix;

=head1 NAME

SearchMatrix.pm - class defining a search matrix

=head1 SYNOPSIS

matrixSearch.pl <input fasta> <output> [OPTIONS]

=head1 DESCRIPTION

Defines the SearchMatrix class. Provides an easy interface for loading in
a matrix file generated by align_convert.pl and calculating core similarity
and matrix similarity (as defined by the Genomatix algorithm).

=head1 EXAMPLES

# load a matrix and calculate its similarity against a sequence
my $searchMatrix = SearchMatrix->new("TATA matrix", "tataatMatrix.html");
$coreSimilarity = $searchMatrix->getCoreSimilarity("TATATT");
$matrixSimilarity = $searchMatrix->getSimilarity("TATATT");	

=head1 AUTHOR

Brady Olsen

=cut

use HTML::TreeBuilder;
use strict;

# constructor for the matrix object. call load_from_html to initialize
sub new {
	my ($class, $name, $filename) = @_;
	my $self = {
		_name => undef,
		_matrix => undef,
		_matrixLength => undef,
		_maxScoreSum => undef,
		_corePosition => undef,
		_maxCoreScoreSum => undef 
	};
	bless $self, $class;
	
	# initialize object
	$self->{_name} = $name if defined($name);
	$self->loadFromHtml($filename) if defined($filename);
	
	return $self;
}

sub name {
	my ($self, $name) = @_;
	$self->{_name} = $name if defined($name);
	return ($self->{_name});
}

sub freq() {
	my ($self, $base, $pos, $val) = @_;
	$self->{_matrix}{$base}[$pos] = $val if defined($val);
	return $self->{_matrix}{$base}[$pos];	
}

# displays the matrix information
sub print {
	my ($self) = @_;
	
	print "Name = $self->{_name}\n";
	print "Matrix Length = $self->{_matrixLength}\n";
	print "Max Score Sum = $self->{_maxScoreSum}\n";
	print "Core Position = $self->{_corePosition}\n";
	print "Core Score Sum = $self->{_maxCoreScoreSum}\n";
	print "\n";
	foreach my $base ('A', 'C', 'G', 'T') {
		print "$base";
		foreach my $pos (1 .. $self->{_matrixLength}) {
			print "\t$self->{_matrix}{$base}[$pos]";
		}
		print "\n";
	}
	print "Ci";
	foreach my $pos (1 .. $self->{_matrixLength}) {
		print "\t$self->{_matrix}{'ci'}[$pos]";
	}
	print "\n";
	print "\n";
	
}

# loads the matrix data from an html file made by CreateMatrix.pl
sub loadFromHtml {
	my ($self, $filename) = @_;
	
	# generate an html tag tree from input file
	my $htmlTree = HTML::TreeBuilder->new();
	$htmlTree->parse_file($filename);

	# get base a freqeuency array from html table
	foreach my $base ('A', 'C', 'G', 'T') {
		my $baseTree = $htmlTree->look_down('name', 'freq'.$base);
		my @elements = $baseTree->content_list();
		$self->{_matrixLength} = scalar(@elements) - 1; # less header
		for (my $i = 1; $i < scalar(@elements); $i++) {
			$self->{_matrix}{$base}[$i] = $elements[$i]->as_text();
		}
	}

	# get ci array from html table, merge with matrix
	my $ciTree = $htmlTree->look_down('name', 'ci');
	my @elements = $ciTree->content_list;
	for (my $i = 1; $i < scalar(@elements); $i++) {
		$self->{_matrix}{'ci'}[$i] = $elements[$i]->as_text();
	}
	
	$self->{_maxScoreSum} = $self->getMaxScoreSum();
	$self->{_corePosition} = $self->getCorePosition();
	$self->{_maxCoreScoreSum} = $self->getMaxCoreScoreSum();
}

# gets the core position within the matrix
sub getCorePosition {
	my ($self) = @_;
	
	my $corePos = 0;
	my $maxSumCi = 0;
	foreach my $matrixPos (1 .. $self->{_matrixLength} - 4) { 
		# calculate ci sum for a 4 nt window
		my $sumCi = 0;
		foreach my $offset (0 .. 3) {
			$sumCi += $self->{_matrix}{'ci'}[$matrixPos + $offset];
		}
		# if ci sum is maximal, set position as core offset
		if ($sumCi > $maxSumCi) {
			$corePos = $matrixPos;
			$maxSumCi = $sumCi;
		}
	}
	return $corePos;	
}

# computes the maximum matrix score sum possible for this matrix
sub getMaxScoreSum {
	my ($self) = @_;
	
	my $scoreSum = 0;
	foreach my $matrixPos (1 .. $self->{_matrixLength}) { 
		$scoreSum += $self->getMaxScore($matrixPos);
	}
	return $scoreSum;
}

# computes the maximum matrix core score
sub getMaxCoreScoreSum {
	my ($self) = @_;
	
	my $scoreSum = 0;
	my $pos = $self->{_corePosition};
	foreach my $matrixPos ($pos .. $pos + 3) { 
		$scoreSum += $self->getMaxScore($matrixPos);
	}
	return $scoreSum;
}


# calculates the maximum score (freq * ci) for a given matrix position
sub getMaxScore {
	my($self, $pos) = @_;
	
	my $maxScore = 0;
	foreach my $base ('A', 'C', 'G', 'T') {
		my $score = $self->getScore($base, $pos);
		if ($score > $maxScore) {
			$maxScore = $score;
		}
	}	
	return $maxScore;
}

# calculate the score of a base (base freq * ci) using the matrix
sub getScore {
	my ($self, $base, $pos) = @_;
	
	my $baseFreq = $self->{_matrix}{$base}[$pos];
	my $ci = $self->{_matrix}{'ci'}[$pos];
	return $baseFreq * $ci;
}

# calculates the core similarity of a given sequence. the sequence
# should be the same length as the matrix.
sub getCoreSimilarity {
	my ($self, $seqString) = @_;
	
	my $sumScore = 0;
	my $sumMaxScore = 0;
	my $offset = $self->{_corePosition};
	foreach my $matrixPos ($offset .. $offset + 3) { 
		my $base = uc(substr($seqString, $matrixPos - 1, 1));
		$sumMaxScore += $self->getMaxScore($matrixPos);	
		$sumScore += $self->getScore($base, $matrixPos);
	}
	return $sumScore / $sumMaxScore;
}

# calculates the matrix similarity of a given sequence. the sequence
# should be the same length as the matrix
sub getSimilarity {
	my ($self, $seqString) = @_;
	
	my $sumScore = 0;
	my $sumMaxScore = 0;
	foreach my $matrixPos (1 .. $self->{_matrixLength}) { 
		my $base = uc(substr($seqString, $matrixPos - 1, 1));
		$sumMaxScore += $self->getMaxScore($matrixPos);	
		$sumScore += $self->getScore($base, $matrixPos);
	}
	return $sumScore / $sumMaxScore;
}


1;